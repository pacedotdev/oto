// Code generated by oto; DO NOT EDIT.

package <%= def.PackageName %>

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
	"fmt"

	"github.com/pkg/errors"
	<%= for (importPath, name) in def.Imports { %><%= name %> "<%= importPath %>"
	<% } %>
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost  string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient 	*http.Client
	// BeforeRequest is an optional hook that gives you the opportunity
	// to inspect or modify the request before it is made.
	// Useful for adding auth headers, for example.
	BeforeRequest func(r *http.Request) error
	// Debug writes a line of debug log output.
	Debug func(s string)
}

// New makes a new Client.
func New(remoteHost string) *Client {
	c := &Client{
		RemoteHost: remoteHost,
		Debug: func(s string) {},
		HTTPClient: &http.Client{Timeout:10*time.Second},
	}
	return c
}

<%= for (service) in def.Services { %>
<%= format_comment_text(service.Comment) %>type <%= service.Name %> struct {
	client *Client
}

// New<%= service.Name %> makes a new client for accessing <%= service.Name %> services.
func New<%= service.Name %>(client *Client) *<%= service.Name %> {
	return &<%= service.Name %>{
		client: client,
	}
}

<%= for (method) in service.Methods { %>
<%= format_comment_text(method.Comment) %>func (s *<%= service.Name %>) <%= method.Name %>(ctx context.Context, r <%= method.InputObject.TypeName %>) (*<%= method.OutputObject.TypeName %>, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>.<%= method.Name %>: marshal <%= method.InputObject.TypeName %>")
	}
	url := s.client.RemoteHost + "<%= service.Name %>.<%= method.Name %>"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>.<%= method.Name %>: NewRequest")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>.<%= method.Name %>")
	}
	defer resp.Body.Close()
	var response struct {
		<%= method.OutputObject.TypeName %>
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "<%= service.Name %>.<%= method.Name %>: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "<%= service.Name %>.<%= method.Name %>: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("<%= service.Name %>.<%= method.Name %>: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.<%= method.OutputObject.TypeName %>, nil
}
<% } %>
<% } %>

<%= for (object) in def.Objects { %>
	<%= if (!object.Imported) { %>
		<%= format_comment_text(object.Comment) %>type <%= object.Name %> struct {
			<%= for (field) in object.Fields { %>
				<%= if (field.Name != "Error") { %>
 					<%= format_comment_text(field.Comment) %><%= field.Name %> <%= if (field.Type.Multiple == true) { %>[]<% } %><%= field.Type.TypeName %> `json:"<%= field.NameLowerCamel %><%= if (field.OmitEmpty) { %>,omitempty<% } %>"`
				<% } %>
			<% } %>
		}
	<% } %>
<% } %>
