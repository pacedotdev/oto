// Code generated by oto; DO NOT EDIT.

import { z } from 'zod';
import type { Schema, ZodTypeDef, ZodError } from 'zod';

type JsonPrimitive = string | number | boolean | undefined;
export type Json = JsonPrimitive | JsonObject | JsonArray;
type JsonObject = { [member: string]: Json } | {};
interface JsonArray extends ReadonlyArray<Json> {}

export type ClientResponse =
  | {
      success: false;
      error: { status: number; statusText: string; message: string };
    }
  | { success: true; payload: Json };

export type Client = {
  fetch: (path: string, payload: Json) => Promise<ClientResponse>;
};

/**
 * Decode json to a zod schema
 */
export async function decodeJson<T extends { error?: string }>(
  something: Json,
  schema: Schema<T, ZodTypeDef, Json>
): Promise<APIResponse<T>> {
  const result = await schema.safeParseAsync(something);
  if (result.success) {
    const { error } = result.data;
    if (error !== undefined && error?.length > 0) {
      return {
        success: false,
        error: {
          status: 400,
          statusText: 'API error',
          message: error,
        },
      };
    }
  }
  return result;
}

export type APIResponse<T> =
  | {
      success: false;
      error: ZodError<Json> | { status: number; statusText: string; message: string };
    }
  | { success: true; data: Omit<T, 'error'> };

<%= for (object) in def.Objects { %>
<%= format_comment_text(object.Comment) %>export function <%= object.Name %>Schema() { return z.object({
    <%= for (field) in object.Fields { %>
     <%= field.NameLowerCamel %>: <%= if (field.Type.IsObject) { %>
        <%= field.Type.TSType %>Schema()
      <% } else if (field.Metadata["options"]) { %>
z.enum([<%= for (option) in field.Metadata["options"] { %>'<%= option %>',<% } %> ""])
      <% } else if (field.Type.JSType == "object") { %>
        z.record(z.unknown())
      <% } else { %> z.<%= field.Type.JSType %>() <% } %><%= if (field.Type.Multiple) { %>.array()<% } %><%= if (field.Metadata["optional"]) {%>.optional()<%}%> ,<% } %>
  });
}

  export type <%= object.Name %> = z.infer<ReturnType<typeof <%= object.Name %>Schema>>;


<% } %>


<%= for (service) in def.Services { %>
<%= if (service.Metadata["deprecated"]) { %>
    /**
    * @deprecated  <%= service.Metadata["deprecated"] %>
    */
<% } else { %><%= format_comment_text(service.Comment) } %>export class <%= service.Name %> {
  private readonly _client: Client;
  public constructor(client: Client) {
    this._client = client;
  }
  <%= for (method) in service.Methods { %>
  <%= if (method.Metadata["deprecated"]) { %>
    /**
    * @deprecated  <%= method.Metadata["deprecated"] %>
    */
  <% } else { %><%= format_comment_text(method.Comment) } %>public async <%= method.NameLowerCamel %>(<%= camelize_down(method.InputObject.TSType) %>: <%= method.InputObject.TSType %>): Promise<
 APIResponse<<%= method.OutputObject.TSType %>> 
  > {
    const response = await this._client.fetch('<%= service.Name %>.<%= method.Name %>', <%= camelize_down(method.InputObject.TSType) %>);
    if (!response.success) {
      return response;
    }
    return decodeJson(response.payload, <%= method.OutputObject.TSType %>Schema());
  }
  <% } %>
}
<% } %>

