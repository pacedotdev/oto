use std::io::Read;
use rocket::{Request, State, Data, Outcome::*};
use rocket::data::{self, FromDataSimple, Outcome};
use rocket::http::{ContentType, Status};
use rocket::response::{self, Responder, Response};
use rocket_contrib::json::Json;
use serde_json;
use std::io::Cursor;
use crate::types::*;

<%= for (service) in def.Services { %>
<%= for (method) in service.Methods { %>
#[post("/oto/<%= service.Name %>.<%= method.Name %>", format = "json", data = "<data>")]
fn <%= underscore(service.Name) %>_<%= underscore(method.Name) %>(data: <%= method.InputObject.TypeName %>, svc: State<Box<dyn <%= service.Name %>>>) -> Json<<%= method.OutputObject.TypeName %>> {
    match svc.<%= underscore(method.Name) %>(data) {
        Ok(resp) => Json(resp),
        Err(msg) => Json(<%= method.OutputObject.TypeName %>::error(msg)),
    }
}
<% } %>

pub struct <%= service.Name %>Server {
    rocket: rocket::Rocket,
}

impl <%= service.Name %>Server {
    pub fn new(svc: Box<dyn <%= service.Name %>>) -> <%= service.Name %>Server {
        let rocket = rocket::ignite()
            .mount("/", routes![
                <%= for (method) in service.Methods { %>
                    <%= underscore(service.Name) %>_<%= underscore(method.Name) %>,
                <% } %>
            ])
            .manage(svc);
        <%= service.Name %>Server { rocket }
    }

    pub fn listen(self) -> rocket::error::LaunchError {
        self.rocket.launch()
    }
}

<% } %>

<%= for (object) in def.Objects { %>

impl FromDataSimple for <%= object.Name %> {
    type Error = String;


    fn from_data(req: &Request, data: Data) -> Outcome<Self, String> {
        let json_ct = ContentType::new("application", "json");
        if req.content_type() != Some(&json_ct) {
            return Outcome::Forward(data);
        }
        let mut body = String::new();
        if let Err(e) = data.open().read_to_string(&mut body) {
            return Failure((Status::InternalServerError, format!("{:?}", e)));
        }
        match serde_json::from_str::<<%= object.Name %>>(&body) {
            Ok(value) => Success(value),
            Err(e) => Failure((Status::BadRequest, format!("{:?}", e))),
        }
    }
}

<%= if (has(object, "Error")) { %>
impl<'a> Responder<'a> for <%= object.Name %> {
    fn respond_to(self, _: &Request) -> response::Result<'a> {
        let status = match self.is_error() {
            true => Status::InternalServerError,
            false => Status::Ok,
        };
        let body = match serde_json::to_string(&self) {
            Ok(body) => body,
            Err(e) => panic!("unable to serialize response json"),
        };
        Response::build()
            .header(ContentType::JSON)
            .status(status)
            .sized_body(Cursor::new(body))
            .ok()
    }
}
<% } %>
<% } %>

#[cfg(test)]
mod test {
    
<%= for (service) in def.Services { %>
mod <%= underscore(service.Name) %> {
    use super::super::*;
    
    struct Mock<%= service.Name %> {
        error: Option<&'static str>,
    }

    impl Mock<%= service.Name %> {
        fn new() -> Mock<%= service.Name %> {
            Mock<%= service.Name %> { error: None }
        }

        fn error(message: &'static str) -> Mock<%= service.Name %> {
            Mock<%= service.Name %>{ error: Some(message) }
        }
    }

    <%= for (embedded) in service.Embedded { %>
        impl <%= embedded.Name %> for Mock<%= service.Name %> {
            <%= for (method) in embedded.Unique { %>
                fn <%= underscore(method.Name) %>(&self, _ :<%= method.InputObject.TypeName %>) -> Result<<%= method.OutputObject.TypeName %>, String> {
                    match self.error {
                        Some(msg) => Err(String::from(msg)),
                        None => Ok(Default::default()),
                    }
                }
            <% } %>
        }
    <% } %>

    impl <%= service.Name %> for Mock<%= service.Name %> {
        <%= for (method) in service.Unique { %>
            fn <%= underscore(method.Name) %>(&self, _ :<%= method.InputObject.TypeName %>) -> Result<<%= method.OutputObject.TypeName %>, String> {
                match self.error {
                    Some(msg) => Err(String::from(msg)),
                    None => Ok(Default::default()),
                }
            }
        <% } %>
    }

    #[test]
    fn test_types() {
        let server = <%= service.Name %>Server::new(Box::new(Mock<%= service.Name %>::new()));
    }

    <%= for (method) in service.Unique { %>
        #[test]
        fn test_<%= underscore(method.Name) %>() {
        }
    <% } %>

    <%= for (embedded) in service.Embedded { %>
    mod <%= underscore(embedded.Name) %> {
        use super::*;

        <%= for (method) in embedded.Unique { %>
            #[test]
        fn test_<%= underscore(method.Name) %>_ok() {
            assert!(Mock<%= service.Name %>::new().<%= underscore(method.Name) %>(Default::default()).is_ok());
        }

        #[test]
        #[should_panic]
        fn test_<%= underscore(method.Name) %>_error() {
            Mock<%= service.Name %>::error("quaranstream")
                .<%= underscore(method.Name) %>(Default::default())
                .expect("should panic because its an error");
        }
    <% } %>
    }
    <% } %>
}
<% } %>
}