use std::io::Read;
use rocket::{Request, State, Data, Outcome::*};
use rocket::data::{self, FromDataSimple, Outcome};
use rocket::http::{ContentType, Status};
use rocket::response::{self, Responder, Response};
use rocket_contrib::json::Json;
use serde_json;
use std::io::Cursor;
use crate::types::*;

<%= for (service) in def.Services { %>
<%= for (method) in service.Methods { %>
#[post("/oto/<%= service.Name %>.<%= method.Name %>", format = "json", data = "<data>")]
fn <%= underscore(service.Name) %>_<%= underscore(method.Name) %>(data: <%= method.InputObject.TypeName %>, svc: State<Box<dyn <%= service.Name %>>>) -> Json<<%= method.OutputObject.TypeName %>> {
    match svc.<%= underscore(method.Name) %>(data) {
        Ok(resp) => Json(resp),
        Err(msg) => Json(<%= method.OutputObject.TypeName %>::error(msg)),
    }
}
<% } %>

pub struct <%= service.Name %>Server {
    rocket: rocket::Rocket,
}

impl <%= service.Name %>Server {
    pub fn new(svc: Box<dyn <%= service.Name %>>) -> <%= service.Name %>Server {
        let rocket = rocket::ignite()
            .mount("/", routes![
                <%= for (method) in service.Methods { %>
                    <%= underscore(service.Name) %>_<%= underscore(method.Name) %>,
                <% } %>
            ])
            .manage(svc);
        <%= service.Name %>Server { rocket }
    }

    pub fn listen(self) -> rocket::error::LaunchError {
        self.rocket.launch()
    }
}

<% } %>

<%= for (object) in def.Objects { %>

impl FromDataSimple for <%= object.Name %> {
    type Error = String;


    fn from_data(req: &Request, data: Data) -> Outcome<Self, String> {
        let json_ct = ContentType::new("application", "json");
        if req.content_type() != Some(&json_ct) {
            return Outcome::Forward(data);
        }
        let mut body = String::new();
        if let Err(e) = data.open().read_to_string(&mut body) {
            return Failure((Status::InternalServerError, format!("{:?}", e)));
        }
        match serde_json::from_str::<<%= object.Name %>>(&body) {
            Ok(value) => Success(value),
            Err(e) => Failure((Status::BadRequest, format!("{:?}", e))),
        }
    }
}

<%= if (has(object, "Error")) { %>
impl<'a> Responder<'a> for <%= object.Name %> {
    fn respond_to(self, _: &Request) -> response::Result<'a> {
        let status = match self.is_error() {
            true => Status::InternalServerError,
            false => Status::Ok,
        };
        let body = match serde_json::to_string(&self) {
            Ok(body) => body,
            Err(e) => return Response::build()
                .header(ContentType::Plain)
                .status(Status::InternalServerError)
                .sized_body(Cursor::new(format!("{:?}", e)))
                .ok(),
        };
        Response::build()
            .header(ContentType::JSON)
            .status(status)
            .sized_body(Cursor::new(body))
            .ok()
    }
}
<% } %>
<% } %>

#[cfg(test)]
mod test {
    use super::*;
<%= for (service) in def.Services { %>
    #[test]
    fn test_<%= underscore_type(service.Name) %>() {
        <%= service.Name %>Server::new(Box::new(Mock<%= service.Name %>::new()));
    }
<% } %>
}
