// Code generated by oto; DO NOT EDIT.
use serde_json::{Value, Map};
use async_trait::async_trait;


<%= for (service) in def.Services { %>

    
#[async_trait]
pub trait <%= service.Name %> : std::marker::Send + std::marker::Sync
<%= if (len(service.Embedded) > 0) { %> 
    <%= for (i, embedded) in service.Embedded { %>
        + <%= embedded.Name %>
    <% } %>
<% } %>
{
    <%= for (method) in service.Unique { %>
	async fn <%= underscore(method.Name) %>(&self, req: <%= method.InputObject.TypeName %>) -> Result<<%= method.OutputObject.TypeName %>, String>;<% } %>
}
<% } %>

<%= for (object) in def.Objects { %>
#[derive(Serialize, Deserialize)]
pub struct <%= object.Name %> {<%= for (field) in object.Fields { %>
    <%= if (field.Name != "Error") { %>pub<% } %>
    <%= underscore(field.Name) %>:
    <%= if (field.OmitEmpty) { %> Option< <% } %>
        <%= if (field.Type.Multiple) { %> Vec< <% } %>
            <%= rust_type(field.Type.TypeName) %>
        <%= if (field.Type.Multiple) { %> > <% } %>
    <%= if (field.OmitEmpty) { %> > <% } %>,
<% } %>}

impl <%= object.Name %> {
    pub fn new() -> Self {
        <%= object.Name %>{
            <%= for (field) in object.Fields { %>
                <%= underscore(field.Name) %>:
                <%= if (field.OmitEmpty) { %>
                    None
                <% } else { %>
                    Default::default()
                <% } %>,
            <% } %>
        }
    }
    
    pub fn make(
        <%= for (field) in object.Fields { %>
            <%= if (field.Name != "Error") { %>
            <%= underscore(field.Name) %>:
            <%= if (field.OmitEmpty) { %> Option< <% } %>
                <%= if (field.Type.Multiple) { %> Vec< <% } %>
                    <%= rust_type(field.Type.TypeName) %>
                <%= if (field.Type.Multiple) { %> > <% } %>
            <%= if (field.OmitEmpty) { %> > <% } %>,
            <% } %>
        <% } %>
    ) -> Self {
        <%= object.Name %>{
            <%= for (field) in object.Fields { %>
                <%= if (field.Name != "Error") { %>
                    <%= underscore(field.Name) %>,
                <% } %>
            <% } %>
            <%= if (has(object, "Error")) { %>
                error: None,
            <% } %>
        }
    }

    <%= if (has(object, "Error")) { %>
    pub fn error(msg: String) -> Self {
        <%= object.Name %>{
            error: Some(msg),
            <%= for (field) in object.Fields { %>
                <%= if (field.Name != "Error") { %>
                    <%= underscore(field.Name) %>:
                    <%= if (field.OmitEmpty) { %>
                        None
                    <% } else { %>
                        Default::default()
                    <% } %>,
                <% } %>
            <% } %>
        }
    }

    pub(crate) fn is_error(&self) -> bool {
        self.error != None
    }
    
    pub(crate) fn get_error(&self) -> Option<&String> {
        self.error.as_ref()
    }

    pub(crate) fn take_error(&mut self) -> Option<String> {
        self.error.take()
    }
    <% } %>
}

impl Default for <%= object.Name %> {
    fn default() -> <%= object.Name %> {
        <%= object.Name %>::new()
    }
}

<% } %>

pub mod mock {
    use super::*;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("error: {0}")]
        MockError(&'static str),
    }

<%= for (service) in def.Services { %>

#[derive(Clone)]
pub struct Mock<%= service.Name %> {
    error: Option<&'static str>,
}

impl Mock<%= service.Name %> {
    pub fn new() -> Mock<%= service.Name %> {
        Mock<%= service.Name %> { error: None }
    }

    pub fn error(message: &'static str) -> Mock<%= service.Name %> {
        Mock<%= service.Name %>{ error: Some(message) }
    }
}

<%= for (embedded) in service.Embedded { %>
    #[async_trait]
    impl <%= embedded.Name %> for Mock<%= service.Name %> {
        <%= for (method) in embedded.Unique { %>
            async fn <%= underscore(method.Name) %>(&self, _ :<%= method.InputObject.TypeName %>) -> Result<<%= method.OutputObject.TypeName %>, String> {
                match self.error {
                    Some(err) => Err(String::from(err)),
                    None => Ok(Default::default()),
                }
            }
        <% } %>
    }
<% } %>

#[async_trait]
impl <%= service.Name %> for Mock<%= service.Name %> {
    <%= for (method) in service.Unique { %>
        async fn <%= underscore(method.Name) %>(&self, _ :<%= method.InputObject.TypeName %>) -> Result<<%= method.OutputObject.TypeName %>, String> {
            match self.error {
                Some(err) => Err(String::from(err)),
                None => Ok(Default::default()),
            }
        }
    <% } %>
}
<% } %>
}

#[cfg(test)]
mod test {
    use super::*;
    use super::mock::*;
    
<%= for (service) in def.Services { %>
mod <%= underscore(service.Name) %> {
    use super::*;

    <%= for (method) in service.Unique { %>
        #[tokio::test]
        async fn <%= underscore(method.Name) %>_ok() {
            assert!(Mock<%= service.Name %>::new().<%= underscore(method.Name) %>(<%= method.InputObject.TypeName %>::new()).await.is_ok());
        }

        #[tokio::test]
        async fn <%= underscore(method.Name) %>_error() {
            assert_eq!(Mock<%= service.Name %>::error("hello from Mock<%= service.Name %>")
                .<%= underscore(method.Name) %>(<%= method.InputObject.TypeName %>::new())
                .await
                .err()
                .unwrap(),
                "hello from Mock<%= service.Name %>");
        }
    <% } %>

    <%= for (embedded) in service.Embedded { %>
    mod <%= underscore(embedded.Name) %> {
        use super::*;

        <%= for (method) in embedded.Unique { %>
            #[tokio::test]
            async fn <%= underscore(method.Name) %>_ok() {
                assert!(Mock<%= service.Name %>::new().<%= underscore(method.Name) %>(<%= method.InputObject.TypeName %>::new()).await.is_ok());
            }

            #[tokio::test]
            async fn <%= underscore(method.Name) %>_error() {
                assert_eq!(Mock<%= service.Name %>::error("hello from Mock<%= service.Name %>")
                    .<%= underscore(method.Name) %>(<%= method.InputObject.TypeName %>::new())
                    .await
                    .err()
                    .unwrap(),
                    "hello from Mock<%= service.Name %>");
            }
        <% } %>
    }
    <% } %>
}
<% } %>
}